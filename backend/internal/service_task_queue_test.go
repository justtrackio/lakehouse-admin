package internal_test

import (
	"context"
	"database/sql"
	"regexp"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/gosoline-project/sqlc"
	"github.com/jmoiron/sqlx"
	"github.com/justtrackio/gosoline/pkg/exec"
	logmocks "github.com/justtrackio/gosoline/pkg/log/mocks"
	"github.com/justtrackio/lakehouse-admin/internal"
	"github.com/stretchr/testify/suite"
)

// SQL patterns for ClaimTask - these match the actual queries generated by sqlc
var (
	// SELECT query: columns are generated from Task struct tags via ForType()
	// LIMIT is parameterized as LIMIT ?
	claimTaskSelectSQL = regexp.QuoteMeta("SELECT `id`, `table`, `kind`, `started_at`, `picked_up_at`, `finished_at`, `status`, `error_message`, `input`, `result` FROM `tasks` WHERE `status` = ? AND `table` NOT IN (SELECT `table` FROM `tasks` WHERE `status` = ?) ORDER BY `started_at` ASC LIMIT ?")

	// UPDATE query for claiming a task - note: sqlc wraps Eq conditions in parentheses
	claimTaskUpdateSQL = regexp.QuoteMeta("UPDATE `tasks` SET `status` = ?, `picked_up_at` = ? WHERE (`id` = ? AND `status` = ?)")
)

type ServiceTaskQueueSuite struct {
	suite.Suite
	sqlDB     *sql.DB
	mock      sqlmock.Sqlmock
	sqlClient sqlc.Client
	service   *internal.ServiceTaskQueue
}

func (s *ServiceTaskQueueSuite) SetupTest() {
	var err error

	// Create go-sqlmock with regex query matching and monitoring
	s.sqlDB, s.mock, err = sqlmock.New(
		sqlmock.QueryMatcherOption(sqlmock.QueryMatcherRegexp),
		sqlmock.MonitorPingsOption(true),
	)
	s.Require().NoError(err)

	// Wrap with sqlx
	sqlxDB := sqlx.NewDb(s.sqlDB, "mysql")

	// Create sqlc.Client via NewClientWithInterfaces
	logger := logmocks.NewLoggerMock(logmocks.WithMockAll)
	executor := exec.NewDefaultExecutor()
	qbConfig := sqlc.DefaultConfig()

	s.sqlClient = sqlc.NewClientWithInterfaces(logger, sqlxDB, executor, qbConfig)

	// Create ServiceTaskQueue directly
	s.service = internal.NewServiceTaskQueueForTest(
		logger,
		s.sqlClient,
	)
}

func (s *ServiceTaskQueueSuite) TearDownTest() {
	s.NoError(s.mock.ExpectationsWereMet())
	s.NoError(s.sqlDB.Close())
}

func TestServiceTaskQueueSuite(t *testing.T) {
	suite.Run(t, new(ServiceTaskQueueSuite))
}

// TestClaimTask_ReturnsNil_WhenQueueEmpty tests that ClaimTask returns nil when no queued tasks exist
func (s *ServiceTaskQueueSuite) TestClaimTask_ReturnsNil_WhenQueueEmpty() {
	ctx := context.Background()

	// Expect SELECT query that finds no rows
	s.mock.ExpectQuery(claimTaskSelectSQL).
		WithArgs("queued", "running", 1).
		WillReturnError(sql.ErrNoRows)

	task, err := s.service.ClaimTask(ctx)

	s.NoError(err)
	s.Nil(task)
}

// TestClaimTask_ClaimsTask_Successfully tests successful task claiming
func (s *ServiceTaskQueueSuite) TestClaimTask_ClaimsTask_Successfully() {
	ctx := context.Background()

	now := time.Now()
	taskRow := sqlmock.NewRows([]string{"id", "table", "kind", "started_at", "picked_up_at", "finished_at", "status", "error_message", "input", "result"}).
		AddRow(int64(1), "test_table", "optimize", now, nil, nil, "queued", nil, []byte(`{}`), []byte(`{}`))

	// Expect SELECT query
	s.mock.ExpectQuery(claimTaskSelectSQL).
		WithArgs("queued", "running", 1).
		WillReturnRows(taskRow)

	// Expect UPDATE query with RowsAffected = 1
	s.mock.ExpectExec(claimTaskUpdateSQL).
		WithArgs("running", sqlmock.AnyArg(), int64(1), "queued").
		WillReturnResult(sqlmock.NewResult(0, 1))

	task, err := s.service.ClaimTask(ctx)

	s.NoError(err)
	s.NotNil(task)
	if task != nil {
		s.Equal(int64(1), task.Id)
		s.Equal("test_table", task.Table)
		s.Equal("optimize", task.Kind)
		s.Equal("running", task.Status)
		s.NotNil(task.PickedUpAt)
	}
}

// TestClaimTask_SkipsTable_WithRunningTask tests per-table exclusivity
func (s *ServiceTaskQueueSuite) TestClaimTask_SkipsTable_WithRunningTask() {
	ctx := context.Background()

	// The key test: verify the SQL contains the NOT IN subquery
	// When a table has a running task, queued tasks for that table should be skipped
	s.mock.ExpectQuery(claimTaskSelectSQL).
		WithArgs("queued", "running", 1).
		WillReturnError(sql.ErrNoRows) // No eligible tasks (all queued tasks are for tables with running tasks)

	task, err := s.service.ClaimTask(ctx)

	s.NoError(err)
	s.Nil(task)
}

// TestClaimTask_RetriesOnConflict tests retry logic when another worker claims the task
func (s *ServiceTaskQueueSuite) TestClaimTask_RetriesOnConflict() {
	ctx := context.Background()

	now := time.Now()
	taskRow := sqlmock.NewRows([]string{"id", "table", "kind", "started_at", "picked_up_at", "finished_at", "status", "error_message", "input", "result"}).
		AddRow(int64(1), "test_table", "optimize", now, nil, nil, "queued", nil, []byte(`{}`), []byte(`{}`))

	// First attempt: SELECT succeeds, UPDATE returns 0 rows (conflict)
	s.mock.ExpectQuery(claimTaskSelectSQL).
		WithArgs("queued", "running", 1).
		WillReturnRows(taskRow)

	s.mock.ExpectExec(claimTaskUpdateSQL).
		WithArgs("running", sqlmock.AnyArg(), int64(1), "queued").
		WillReturnResult(sqlmock.NewResult(0, 0)) // 0 rows affected = conflict

	// Second attempt: SELECT succeeds, UPDATE succeeds
	taskRow2 := sqlmock.NewRows([]string{"id", "table", "kind", "started_at", "picked_up_at", "finished_at", "status", "error_message", "input", "result"}).
		AddRow(int64(2), "test_table2", "optimize", now, nil, nil, "queued", nil, []byte(`{}`), []byte(`{}`))

	s.mock.ExpectQuery(claimTaskSelectSQL).
		WithArgs("queued", "running", 1).
		WillReturnRows(taskRow2)

	s.mock.ExpectExec(claimTaskUpdateSQL).
		WithArgs("running", sqlmock.AnyArg(), int64(2), "queued").
		WillReturnResult(sqlmock.NewResult(0, 1))

	task, err := s.service.ClaimTask(ctx)

	s.NoError(err)
	s.NotNil(task)
	s.Equal(int64(2), task.Id)
}

// TestClaimTask_ReturnsNil_AfterMaxRetries tests that ClaimTask gives up after 3 failed attempts
func (s *ServiceTaskQueueSuite) TestClaimTask_ReturnsNil_AfterMaxRetries() {
	ctx := context.Background()

	now := time.Now()

	// All 3 attempts: SELECT succeeds, UPDATE returns 0 rows
	for i := 0; i < 3; i++ {
		taskRow := sqlmock.NewRows([]string{"id", "table", "kind", "started_at", "picked_up_at", "finished_at", "status", "error_message", "input", "result"}).
			AddRow(int64(1), "test_table", "optimize", now, nil, nil, "queued", nil, []byte(`{}`), []byte(`{}`))

		s.mock.ExpectQuery(claimTaskSelectSQL).
			WithArgs("queued", "running", 1).
			WillReturnRows(taskRow)

		s.mock.ExpectExec(claimTaskUpdateSQL).
			WithArgs("running", sqlmock.AnyArg(), int64(1), "queued").
			WillReturnResult(sqlmock.NewResult(0, 0))
	}

	task, err := s.service.ClaimTask(ctx)

	s.NoError(err)
	s.Nil(task)
}

// TestEnqueueTask tests task insertion
func (s *ServiceTaskQueueSuite) TestEnqueueTask() {
	ctx := context.Background()

	input := map[string]any{"file_size_threshold_mb": 100}

	// The query builder includes all struct fields in the INSERT, not just the ones we set
	s.mock.ExpectExec("INSERT INTO `tasks` \\(`id`, `table`, `kind`, `started_at`, `picked_up_at`, `finished_at`, `status`, `error_message`, `input`, `result`\\) VALUES \\(\\?, \\?, \\?, \\?, \\?, \\?, \\?, \\?, \\?, \\?\\)").
		WithArgs(sqlmock.AnyArg(), "test_table", "optimize", sqlmock.AnyArg(), sqlmock.AnyArg(), sqlmock.AnyArg(), "queued", sqlmock.AnyArg(), sqlmock.AnyArg(), sqlmock.AnyArg()).
		WillReturnResult(sqlmock.NewResult(123, 1))

	id, err := s.service.EnqueueTask(ctx, "test_table", "optimize", input)

	s.NoError(err)
	s.Equal(int64(123), id)
}

// TestCompleteTask_Success tests successful task completion
func (s *ServiceTaskQueueSuite) TestCompleteTask_Success() {
	ctx := context.Background()

	result := map[string]any{"status": "ok", "files_merged": 10}

	s.mock.ExpectExec(regexp.QuoteMeta("UPDATE `tasks` SET `finished_at` = ?, `status` = ?, `error_message` = ?, `result` = ? WHERE `id` = ?")).
		WithArgs(sqlmock.AnyArg(), "success", nil, sqlmock.AnyArg(), int64(1)).
		WillReturnResult(sqlmock.NewResult(0, 1))

	err := s.service.CompleteTask(ctx, 1, result, nil)

	s.NoError(err)
}

// TestCompleteTask_Error tests task completion with error
func (s *ServiceTaskQueueSuite) TestCompleteTask_Error() {
	ctx := context.Background()

	result := map[string]any{"status": "failed"}
	taskErr := sql.ErrNoRows

	s.mock.ExpectExec(regexp.QuoteMeta("UPDATE `tasks` SET `finished_at` = ?, `status` = ?, `error_message` = ?, `result` = ? WHERE `id` = ?")).
		WithArgs(sqlmock.AnyArg(), "error", sqlmock.AnyArg(), sqlmock.AnyArg(), int64(1)).
		WillReturnResult(sqlmock.NewResult(0, 1))

	err := s.service.CompleteTask(ctx, 1, result, taskErr)

	s.NoError(err)
}
